
#include "utils.hpp"
#include <botan/pem.h>
#include <botan/base64.h>
#include <cstdio>
#include <stdexcept>
#include <sstream>
#include <iostream>


// https://stackoverflow.com/questions/6855115/byte-array-to-int-c
uint32_t Utils::arrayToUInt32(const uint8_t* byteArray, int32_t offset)
{
  return *reinterpret_cast<const uint32_t*>(&byteArray[offset]);
}



char* Utils::getAsHex(const uint8_t* data, int len)
{
  char* hexStr = new char[len * 2 + 3];
  hexStr[0] = '0';
  hexStr[1] = 'x';
  for (int i = 0; i < len; i++)
    sprintf(&hexStr[i * 2 + 2], "%02x", data[i]);
  return hexStr;
}



bool Utils::isPowerOfTwo(std::size_t x)
{  // glibc method of checking
  return ((x != 0) && !(x & (x - 1)));
}



unsigned long Utils::decode64Estimation(unsigned long inSize)
{  // https://stackoverflow.com/questions/1533113/calculate-the-size-to-a-base-64-encoded-message
  return ((inSize * 4) / 3) + (inSize / 96) + 6;
}



// https://stackoverflow.com/questions/1494399/how-do-i-search-find-and-replace-in-a-standard-string
void Utils::stringReplace(std::string& str,
                          const std::string& find,
                          const std::string& replace)
{
  size_t pos = 0;
  while ((pos = str.find(find, pos)) != std::string::npos)
  {
    str.replace(pos, find.length(), replace);
    pos += replace.length();
  }
}



// https://stackoverflow.com/questions/874134/
bool Utils::strEndsWith(const std::string& str, const std::string& ending)
{
  if (str.length() >= ending.length())
    return (
        0 ==
        str.compare(str.length() - ending.length(), ending.length(), ending));
  else
    return false;
}



Botan::RSA_PublicKey* Utils::base64ToRSA(const std::string& base64)
{
  // decode public key
  unsigned long expectedSize = decode64Estimation(base64.length());
  uint8_t* keyBuffer = new uint8_t[expectedSize];
  size_t len = Botan::base64_decode(keyBuffer, base64, false);

  // interpret and parse into public RSA key
  std::istringstream iss(std::string(reinterpret_cast<char*>(keyBuffer), len));
  Botan::DataSource_Stream keyStream(iss);
  return dynamic_cast<Botan::RSA_PublicKey*>(Botan::X509::load_key(keyStream));
}



Botan::RSA_PrivateKey* Utils::loadKey(const std::string& filename,
                                      Botan::RandomNumberGenerator& rng)
{
  try
  {
    // attempt reading key as standardized PKCS8 format
    // std::cout << "Opening " << filename << " as PKCS8..." << std::endl;
    auto pvtKey = Botan::PKCS8::load_key(filename, rng);
    auto rsaKey = dynamic_cast<Botan::RSA_PrivateKey*>(pvtKey);
    if (!rsaKey)
      throw std::invalid_argument("The loaded key is not a RSA key!");
    return rsaKey;
  }
  catch (Botan::Decoding_Error&)
  {
    // std::cerr << de.what() << std::endl;
    // std::cerr << "  " << filename << " may not be PKCS8-formatted, and likely
    // has been generated by OpenSSL." << std::endl;
    // std::cerr << "  \"openssl pkcs8 -topk8 -nocrypt -in " << filename << "\"
    // will convert the key into PKCS8." << std::endl;

    // if PKCS8 decoding fails, try manual decoding of OpenSSL's format
    // std::cout << "Attempting manual decoding..." << std::endl;
    return Utils::loadOpenSSLRSA(filename, rng);
  }

  return NULL;
}



// http://botan.randombit.net/faq.html#how-do-i-load-this-key-generated-by-openssl-into-botan
// http://lists.randombit.net/pipermail/botan-devel/2010-June/001157.html
// http://lists.randombit.net/pipermail/botan-devel/attachments/20100611/1d8d870a/attachment.cpp
Botan::RSA_PrivateKey* Utils::loadOpenSSLRSA(const std::string& filename,
                                             Botan::RandomNumberGenerator& rng)
{
  Botan::DataSource_Stream in(filename);

  Botan::DataSource_Memory key_bits(
      Botan::PEM_Code::decode_check_label(in, "RSA PRIVATE KEY"));

  // Botan::u32bit version;
  size_t version;
  Botan::BigInt n, e, d, p, q;

  Botan::BER_Decoder(key_bits)
      .start_cons(Botan::SEQUENCE)
      .decode(version)
      .decode(n)
      .decode(e)
      .decode(d)
      .decode(p)
      .decode(q);

  if (version != 0)
    return NULL;

  return new Botan::RSA_PrivateKey(rng, p, q, e, d, n);
}



// This function assumes src to be a zero terminated sanitized string with
// an even number of [0-9a-f] characters, and target to be sufficiently large
void Utils::hex2bin(const char* src, uint8_t* target)
{  // https://stackoverflow.com/questions/17261798/converting-a-hex-string-to-byte-array-in-c
  while (*src && src[1])
  {
    *(target++) = char2int(*src) * 16 + char2int(src[1]);
    src += 2;
  }
}



uint8_t Utils::char2int(const char c)
{
  if (c >= '0' && c <= '9')
    return c - '0';
  if (c >= 'A' && c <= 'F')
    return c - 'A' + 10;
  if (c >= 'a' && c <= 'f')
    return c - 'a' + 10;

  throw std::runtime_error("Invalid character");
}
